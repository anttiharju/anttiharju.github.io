Antti's articles

# pre-commit hooks are useful

`2025-12-28` - `git` `workflows` `devtools`

In response to https://jyn.dev/pre-commit-hooks-are-fundamentally-broken/.

I use https://lefthook.dev in my own projects and it has saved me a ton of time.

Let's start a new Rust project.

```sh
$ mkdir fizzbuzz
$ cd fizzbuzz
$ cat << EOF > main.rs
fn main() { for i in 0.. {
    println ("fizzbuzz");
}}
EOF
$ git init
Initialized empty Git repository in /Users/antti/fizzbuzz/.git/
$ git add --all
$ git commit -m fizzbuzz
[main (root-commit) 1400cdd] fizzbuzz
 1 file changed, 3 insertions(+)
 create mode 100644 main.rs
```

Neat. Now let's say I add this to some list of fizzbuzz projects in different languages. Maybe .... [this one](https://github.com/joshkunz/fizzbuzz). They tell me I need to have "proper formatting" and "use consistent style". How thoughtful.

Maybe I can write a pre-commit hook that checks that for me?

```sh
$ cat << 'EOF' > lefthook.yml
output:
  - success
  - failure

pre-commit:
  jobs:
    - glob: "*.rs"
      run: rustfmt {staged_files}
      stage_fixed: true
EOF
$ lefthook install
$ git add --all
$ git commit --message "add pre-commit hook"
[main 04a881c] add pre-commit hook
 1 file changed, 9 insertions(+)
 create mode 100644 lefthook.yml
```

We are now setup, neat! Maybe we will make one last tweak...

```sh
$ sed -i '1i // Written by jyn' main.rs
$ git add --all
$ git commit main.rs --message "mark who wrote fizzbuzz"
✔️ rustfmt {staged_files} (0.02 seconds)
[main 5e41217] mark who wrote fizzbuzz
 1 file changed, 6 insertions(+), 3 deletions(-)
```

`rustfmt` ran automatically in 0.02 seconds. Neat!

Let's demonstrate the robustness of the Lefthook job.

```sh
$ git switch -c simulated-old-branch
Switched to a new branch 'simulated-old-branch'
$ git reset HEAD~1 --hard
HEAD is now at 04a881c add pre-commit hook
$ echo 'fn main() { println!("this counts as fizzbuzz, right?"); }' > print.rs
$ git add --all
$ git commit --message "Add print.rs"
✔️ rustfmt {staged_files} (0.02 seconds)
[simulated-old-branch 7c6adb4] Add print.rs
 1 file changed, 3 insertions(+)
 create mode 100644 print.rs
$ cat print.rs
fn main() {
    println!("this counts as fizzbuzz, right?");
}
$ git status
On branch simulated-old-branch
nothing to commit, working tree clean
# notice how main.rs did not change!
```

Neat! Let's run a rebase

```sh
$ git rebase main
Successfully rebased and updated refs/heads/simulated-old-branch.
$ git log -1 --oneline
3057f8a (HEAD -> simulated-old-branch) Add print.rs
$ git commit --amend -m "Add print.rs (after rebase)"
[simulated-old-branch 7ad1d6b] Add print.rs (after rebase)
 Date: Sun Dec 28 09:26:58 2025 +0200
 1 file changed, 3 insertions(+)
 create mode 100644 print.rs
$ git status
On branch simulated-old-branch
nothing to commit, working tree clean
```

Easy peasy lemon squeezy!

1. Our pre-commit works just fine.
2. It appears to not have ran on this rebase. I am uncertain of the exact details, but there appears to be a documentation entry stating one can explicitly skip rebases with `skip: rebase`, see https://lefthook.dev/configuration/skip.html.

Other people may not have had the pre-commit hook in use. That is okay. One should enforce standard in CI, so that anything merged to the default branch would have passed our CI, with a `cargo fmt` check.

Now, some people may argue, that the code they produced works perfectly fine, and they may even state that they _hate_ the fact that CI is blocking them due to a formatting issue. At that point you may ask them to install Lefthook and adopt the setup, and they will not be bothered by such issues again. Everyone gets cleaner diffs and consistent/easy-to-read code to review.

---

Giving a light read to https://blog.plover.com/prog/git/hook-disaster.html, the issue appears to be that a hook failed silently. That has not happened to me with Lefthook, and `rustfmt` / `cargo fmt` should be non-blocking anyway. Please let me know if you are aware of a situation where the lefthook job breaks!

https://dev.to/afl_ext/are-pre-commit-git-hooks-a-good-idea-i-dont-think-so-38j6 raises a valid point. I would not run my entire test suite on pre-commit. pre-push should be fine. But in general investing bit of time into a fast test suite usually pays nice dividends for the general developer experience, even if it requires a bit of rigor. Scanning the rest of the titles, I am not so sure I buy the points they are making. Especially the point about monorepos. It is quite nice not having to coordinate PRs across several repositories in the exactly right order (and hoping the deployments also happen in an acceptable order). Most of the major production incidents I have seen in my (admittedly so far short) career have been about the unit of deployment trying to be smart about granularity. Try to avoid setups that could lead to your changes being half-deployed. And have a robust rollback system.

Now granted, developers are usually busy shipping features and will generally settle for workarounds that allow them to do that. That is ok. I suppose that is why the title 'DevOps Engineer' exists. People who specialise and can get things working nicely. Although too often they are busy with their own toys, not dogfooding the things developers are tolerating. Anyway.

Several tools have fantastic autofixing capabilities. Beyond formatters, https://golangci-lint.run and https://docs.astral.sh/ruff/ come to mind. Easy way to benefit from `stage_fixed` with autofixes is to use `|| true` to ignore failures.

On blocking tools, Some excellent static validators I have had the pleasure of using are https://www.shellcheck.net, https://github.com/rhysd/actionlint, and https://github.com/mpalmer/action-validator. Now, _I_ like to use them in a pre-commit hook because _I_ am yet to experience a false positive from them, and _for me_ the scope of changes with shell scripts and github actions is limited enough that I want to catch all issues in every commit. Although I do admit action-validator's output is quite verbose. I usually just take the output and dump it with the manifest failing it to GitHub Copilot. Regardless, the tool is open source, so someone may submit a pr to improve the situation. I think one person has already expressed interest.

On performance, I recently encountered an issue where action-validator would become slow with the gitignored files from my [nix-direnv](https://github.com/nix-community/nix-direnv) setup. I had recently been dissatisfied with broken relative links in markdown documentation and not being able to find a tool fast enough static validator to catch broken ones, so I built https://github.com/anttiharju/relcheck to do exactly that. And to my pleasure, the same trick of using `git ls-files` worked quite well with action-validator! In one scenario the (as of writing unmerged) https://github.com/mpalmer/action-validator/pull/113 ended up yielding a 66x performance improvement. It is a pretty great feeling to achieve that in a Rust project, which presumably should already be quite performant.

I would love to receive an elaboration on the

> Don't get me started on pre-commit hooks that try to add things to the commit you're about to make.

because I suppose that is what I have just advocated for. Is the issue home-cooked scripting? Opt for simple Lefthook jobs. I do see the [3](https://jyn.dev/pre-commit-hooks-are-fundamentally-broken/#fn-lint-staged) reference, but I suppose if the job is a non-blocking one I am afraid I do not quite follow what the issue is.

Regarding

> "Just don't write bad hooks" doesn't work if I'm working on someone else's project where I don't control the hook.

I think hooks are always optional, enforcement should happen in CI. If the current hooks are unsatisfactory to you, may opt to not use them or try to contribute better ones.

So write your pre-commit hooks as Lefthook jobs! They have saved me a lot of time with

- https://github.com/anttiharju/relcheck
- https://github.com/anttiharju/compare-changes (https://github.com/anttiharju/compare-changes-action)
- https://github.com/anttiharju/find-changes-action
- https://github.com/anttiharju/actions
- https://github.com/anttiharju/vmatch

I am still iterating on the peak performance™ setup that I try to distill to https://github.com/anttiharju/go-starter and https://github.com/anttiharju/rust-starter, but thought to write this article already since people appear to be unaware of Lefthook.

But I would be really happy to see people use https://github.com/anttiharju/relcheck for robust relative markdown links and https://github.com/anttiharju/find-changes-action with https://github.com/anttiharju/compare-changes-action for monorepo setups.
